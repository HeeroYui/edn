<?xml version="1.0" encoding="UTF-8"?>
<EdnLang version="0.1" lang="PHP">
	<ext>.*\.(php|php3|php4|phtml)</ext>
	<pass1><!-- multiline section & parse all file (now) and when modification retrive previous modification -->
		<rule name="doxygen multiline">
			<color>commentDoxygen</color>
			<regex>/\*(\*|!)(.|\r|\n)*?\*/</regex>
			<sub>doxyparse</sub>
		</rule>
		<rule name="comment multiline">
			<color>comment</color>
			<regex>/\*(.|\r|\n)*?(\*/|\0)</regex>
			<sub>TODO</sub>
		</rule>
		<rule name="comment multiline ERROR">
			<color>SYNTAX_ERROR</color>
			<regex>/\*(.|\r|\n)*</regex>
		</rule>
		<rule name="#if 0">
			<color>preprocesseur</color>
			<regex>#[ \t]*if 0(.|\r|\n)*?#(endif|else)</regex>
		</rule>
		<rule name="#if 0 ERROR">
			<color>SYNTAX_ERROR</color>
			<regex>#[ \t]*if 0(.|\r|\n)*</regex>
		</rule>
		<rule name="#preproc">
			<color>preprocesseur</color>
			<regex>#(.|\\[\\\n])*</regex>
		</rule>
		<rule name="inline doxygen">
			<color>commentDoxygen</color>
			<regex>//!.*</regex>
			<sub>doxyparse</sub>
		</rule>
		<rule name="inline comment">
			<color>comment</color>
			<regex>//.*</regex>
			<sub>TODO</sub>
		</rule>
		<rule name="double quote text">
			<color>doubleQuoteText</color>
			<regex>&quot;(.|\\[\\&quot;])*?&quot;</regex> <!-- " -->
		</rule>
		<rule name="simple quote text">
			<color>doubleQuoteText</color>
			<regex>&apos;(.|\\[\\&apos;])*?&apos;</regex> <!-- ' -->
		</rule>
	</pass1>
	<pass2> <!-- Parse on display data ==> nor regenerate every display but every time modification apear -->
		<rule name="my keyword">
			<color>keyword</color>
			<regex>\$[a-zA-Z_][a-zA-Z0-9_]*\b</regex>
		</rule>
		<rule name="">
			<color>keyword</color>
			<regex>(&lt;\?php|php\?&gt;)</regex>
		</rule>
		<rule name="my type">
			<color>type</color>
			<regex>\b(array|bool|boolean|double|float|int|integer|numeric|object|resource|string|unset)\b</regex>
		</rule>
		<rule name="my storage keyword">
			<color>storageKeyword</color>
			<regex>\b(abstract|and|as|break|case|catch|class|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|eval|exit|extends|final|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|interface|isset|list|namespace|new|or|print|private|protected|public|require|require_once|return|static|switch|throw|trait|try|unset|use|var|while|xor)\b</regex>
		</rule>
		<rule name="my common Define">
			<color>commonDefine</color>
			<regex>\b(doubleval|floatval|gettype|intval|print_r|serialize|settype|strval|unserialize|var_dump|var_export)\b</regex>
		</rule>
		<rule name="numeric constant">
			<color>number</color>
			<regex>\b(((0(x|X)[0-9a-fA-F]*)|(\d+\.?\d*|\.\d+)((e|E)(\+|\-)?\d+)?)(L|l|UL|ul|u|U|F|f)?)\b</regex>
		</rule>
		<rule name="my boolean">
			<color>boolean</color>
			<regex>\b(true|false|TRUE|FALSE)\b</regex>
		</rule>
		<rule name="BIG LETTER">
			<color>macro</color>
			<regex>\b([A-Z_][A-Z_0-9]{3,500})\b</regex>
		</rule>
		<rule name="function input">
			<color>inputFunction</color>
			<regex>\b_\w+\b</regex>
		</rule>
		<rule name="Function name">
			<color>functionName</color>
			<regex>\b((\w|_)+[ \t]*\()</regex>
		</rule>
		<rule name="condition">
			<color>boolean</color>
			<regex>==|&lt;=|&gt;=|!=|&lt;{1,2}|&gt;{1,2}|&amp;&amp;|\{|\}</regex>
		</rule>
		<rule name="simpleQuteTextError">
			<color>SYNTAX_ERROR</color>
			<regex>&apos;|&quot;</regex>
		</rule>
	</pass2>
	<pass name="doxyparse">
		<rule name="key">
			<color>doxygen-key</color>
			<regex>(@|\\)[\t ]*\w+</regex>
		</rule>
		<rule name="in-out">
			<color>doxygen-in-out</color>
			<regex>\[(in|in,out|out)\]</regex>
		</rule>
		<rule name="function input">
			<color>inputFunction</color>
			<regex>\b_\w+\b</regex>
		</rule>
	</pass>
	<pass name="TODO">
		<rule name="function input">
			<color>SYNTAX_ERROR</color>
			<regex>TODO[ \t]*:.*</regex>
		</rule>
	</pass>
</EdnLang>